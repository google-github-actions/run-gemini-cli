name: '🏷️ Gemini Automated Issue Triage'

on:
  issues:
    types:
      - 'opened'
      - 'reopened'
  issue_comment:
    types:
      - 'created'
  workflow_dispatch:
    inputs:
      issue_number:
        description: 'issue number to triage'
        required: true
        type: 'number'

concurrency:
  group: '${{ github.workflow }}-${{ github.event.issue.number }}'
  cancel-in-progress: true

defaults:
  run:
    shell: 'bash'

permissions:
  contents: 'read'
  id-token: 'write'
  issues: 'write'
  statuses: 'write'

jobs:
  triage-issue:
    if: >
      github.event_name == 'issues' ||
      github.event_name == 'workflow_dispatch' ||
      (github.event_name == 'issue_comment' &&
       contains(github.event.comment.body, '@gemini-cli /triage') &&
       (github.event.comment.author_association == 'OWNER' ||
        github.event.comment.author_association == 'MEMBER' ||
        github.event.comment.author_association == 'COLLABORATOR'))
    timeout-minutes: 5
    runs-on: 'ubuntu-latest'

    steps:
      - name: 'Checkout repository'
        uses: 'actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683' # ratchet:actions/checkout@v4

      - name: 'Generate GitHub App Token'
        id: 'generate_token'
        if: |-
          ${{ vars.APP_ID != '' }}
        uses: 'actions/create-github-app-token@df432ceedc7162793a195dd1713ff69aefc7379e' # ratchet:actions/create-github-app-token@v2
        with:
          app-id: '${{ vars.APP_ID }}'
          private-key: '${{ secrets.APP_PRIVATE_KEY }}'

      - name: 'Run Gemini Issue Triage'
        uses: './'
        env:
          GITHUB_TOKEN: '${{ steps.generate_token.outputs.token || secrets.GITHUB_TOKEN }}'
          ISSUE_TITLE: '${{ github.event.issue.title }}'
          ISSUE_BODY: '${{ github.event.issue.body }}'
          ISSUE_NUMBER: '${{ github.event.issue.number }}'
          REPOSITORY: '${{ github.repository }}'
          GEMINI_CLI_VERSION: '${{ vars.GEMINI_CLI_VERSION }}'
          OTLP_GOOGLE_CLOUD_PROJECT: '${{ vars.OTLP_GOOGLE_CLOUD_PROJECT }}'
          GCP_WIF_PROVIDER: '${{ vars.GCP_WIF_PROVIDER }}'
          GEMINI_API_KEY: '${{ secrets.GEMINI_API_KEY }}'
          GOOGLE_CLOUD_PROJECT: '${{ vars.GOOGLE_CLOUD_PROJECT }}'
          GOOGLE_CLOUD_LOCATION: '${{ vars.GOOGLE_CLOUD_LOCATION }}'
          GOOGLE_GENAI_USE_VERTEXAI: '${{ vars.GOOGLE_GENAI_USE_VERTEXAI }}'
          GOOGLE_GENAI_USE_GCA: '${{ vars.GOOGLE_GENAI_USE_GCA }}'
          SERVICE_ACCOUNT_EMAIL: '${{ vars.SERVICE_ACCOUNT_EMAIL }}'
        with:
          settings: |-
            {
              "coreTools": [
                "run_shell_command(gh label list)",
                "run_shell_command(gh issue edit)"
              ],
              "telemetry": {
                "enabled": true,
                "target": "gcp"
              },
              "sandbox": false
            }
          prompt: |-
            ## Role

            You are an issue triage assistant. Analyze the current GitHub issue
            and apply the most appropriate existing labels. Use the available
            tools to gather information; do not ask for information to be
            provided.

            ## Steps

            1. Run: `gh label list` to get all available labels.
            2. Review the issue title and body provided in the environment
               variables: "${ISSUE_TITLE}" and "${ISSUE_BODY}".
            3. Select the most relevant labels from the existing labels. If
               available, set labels that follow the `kind/*`, `area/*`, and
               `priority/*` patterns.
            4. Apply the selected labels to this issue using:
               `gh issue edit "${ISSUE_NUMBER}" --add-label "label1,label2"`
            5. If the "status/needs-triage" label is present, remove it using:
               `gh issue edit "${ISSUE_NUMBER}" --remove-label "status/needs-triage"`

            ## Guidelines

            - Only use labels that already exist in the repository
            - Do not add comments or modify the issue content
            - Triage only the current issue
            - Assign all applicable labels based on the issue content
            - Reference all shell variables as "${VAR}" (with quotes and braces)

  deduplicate-issues:
    if: >
      vars.ALLOYDB_INSTANCE_CONNECTION_NAME != '' &&
      (github.event_name == 'issues' ||
      github.event_name == 'workflow_dispatch' ||
      (github.event_name == 'issue_comment' &&
       contains(github.event.comment.body, '@gemini-cli /deduplicate') &&
       (github.event.comment.author_association == 'OWNER' ||
        github.event.comment.author_association == 'MEMBER' ||
        github.event.comment.author_association == 'COLLABORATOR')))
    timeout-minutes: 10
    runs-on: 'ubuntu-latest'

    steps:
      - name: 'Checkout repository'
        uses: 'actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683' # ratchet:actions/checkout@v4

      - name: 'Generate GitHub App Token'
        id: 'generate_token'
        if: |-
          ${{ vars.APP_ID  != '' }}
        uses: 'actions/create-github-app-token@df432ceedc7162793a195dd1713ff69aefc7379e' # ratchet:actions/create-github-app-token@v2
        with:
          app-id: '${{ vars.APP_ID }}'
          private-key: '${{ secrets.APP_PRIVATE_KEY }}'

      - name: 'Authenticate to Google Cloud'
        id: 'auth'
        uses: 'google-github-actions/auth@140bb5113ffb6b65a7e9b937a81fa96cf5064462' # ratchet:google-github-actions/auth@v2
        with:
          token_format: 'access_token'
          workload_identity_provider: '${{ vars.GCP_WIF_PROVIDER }}'
          service_account: '${{ vars.SERVICE_ACCOUNT_EMAIL }}'

      - name: 'Login to GAR'
        uses: 'docker/login-action@74a5d142397b4f367a81961eba4e8cd7edddf772' # ratchet:docker/login-action@v3
        with:
          registry: 'northamerica-northeast1-docker.pkg.dev'
          username: 'oauth2accesstoken'
          password: '${{ steps.auth.outputs.access_token }}'

      - name: 'Download AlloyDB Auth Proxy'
        run: |
          curl -o alloydb-auth-proxy https://storage.googleapis.com/alloydb-auth-proxy/v1.13.4/alloydb-auth-proxy.linux.amd64
          chmod +x alloydb-auth-proxy

      - name: 'Start AlloyDB Auth Proxy'
        run: |-
          ./alloydb-auth-proxy "${{ vars.ALLOYDB_INSTANCE_CONNECTION_NAME }}" --public-ip -i --impersonate-service-account ${{ vars.SERVICE_ACCOUNT_EMAIL }} &

      - name: 'Test AlloyDB Auth Proxy'
        env:
          DB_USER: 'postgres'
          DB_PASS: '${{ secrets.ALLOYDB_DB_PASS }}'
        run: |
          PGPASSWORD=$DB_PASS psql "host=127.0.0.1 port=5432 user=$DB_USER dbname=postgres  sslmode=disable" --command="SELECT 1;"

      - name: 'Run Gemini Issue Deduplication'
        uses: './'
        env:
          GITHUB_TOKEN: '${{ steps.generate_token.outputs.token || secrets.GITHUB_TOKEN }}'
          ISSUE_NUMBER: '${{ github.event.issue.number }}'
          REPOSITORY: '${{ github.repository }}'
          GEMINI_CLI_VERSION: '${{ vars.GEMINI_CLI_VERSION }}'
          OTLP_GOOGLE_CLOUD_PROJECT: '${{ vars.OTLP_GOOGLE_CLOUD_PROJECT }}'
          GCP_WIF_PROVIDER: '${{ vars.GCP_WIF_PROVIDER }}'
          GEMINI_API_KEY: '${{ secrets.GEMINI_API_KEY }}'
          GOOGLE_CLOUD_PROJECT: '${{ vars.GOOGLE_CLOUD_PROJECT }}'
          GOOGLE_CLOUD_LOCATION: '${{ vars.GOOGLE_CLOUD_LOCATION }}'
          GOOGLE_GENAI_USE_VERTEXAI: '${{ vars.GOOGLE_GENAI_USE_VERTEXAI }}'
          SERVICE_ACCOUNT_EMAIL: '${{ vars.SERVICE_ACCOUNT_EMAIL }}'
          DB_USER: 'postgres'
          DB_PASS: '${{ secrets.ALLOYDB_DB_PASS }}'
          INSTANCE_HOST: '127.0.0.1'
          INSTANCE_PORT: '5432'
        with:
          settings: |-
            {
              "mcpServers": {
                "issue_deduplication": {
                  "command": "docker",
                  "args": [
                    "run",
                    "-i",
                    "--rm",
                    "--network=host",
                    "-e",
                    "GITHUB_TOKEN",
                    "-e",
                    "GEMINI_API_KEY",
                    "-e",
                    "DB_USER",
                    "-e",
                    "DB_PASS",
                    "-e",
                    "INSTANCE_HOST",
                    "-e",
                    "INSTANCE_PORT",
                    "northamerica-northeast1-docker.pkg.dev/quacktastic-waffle/run-gemini-cli/issues-dedup-mcp-server:latest"
                  ],
                  "env": {
                    "GITHUB_TOKEN": "${GITHUB_TOKEN}",
                    "GEMINI_API_KEY": "${GEMINI_API_KEY}",
                    "DB_USER": "postgres",
                    "DB_PASS": "${DB_PASS}",
                    "INSTANCE_HOST": "${INSTANCE_HOST}",
                    "INSTANCE_PORT": "${INSTANCE_PORT}"
                  },
                  "enabled": true
                }
              },
              "coreTools": [
                "run_shell_command(echo)",
                "run_shell_command(gh issue comment)",
                "run_shell_command(gh issue view)",
                "run_shell_command(gh issue edit)"
              ],
              "telemetry": {
                "enabled": true,
                "target": "gcp"
              },
              "sandbox": false
            }
          prompt: |-
            ## Role

            You are an issue de-duplication assistant. Your goal is to find
            duplicate issues, label the current issue as a duplicate, and notify
            the user by commenting on the current issue, while avoiding
            duplicate comments.

            ## Steps

            1.  **Find Potential Duplicates:**
                - The repository is ${{ github.repository }} and the issue number is ${{ github.event.issue.number }}.
                - Use the `duplicates` tool with the `repo` and `issue_number` to find potential duplicates for the current issue. Do not use the `threshold` parameter.
                - If no duplicates are found, you are done.
                - Print the JSON output from the `duplicates` tool to the logs.

            2.  **Refine Duplicates List (if necessary):**
                - If the `duplicates` tool returns between 1 and 14 results, you must refine the list.
                - For each potential duplicate issue, run `gh issue view <issue-number> --json title,body,comments` to fetch its content.
                - Also fetch the content of the original issue: `gh issue view "${ISSUE_NUMBER}" --json title,body,comments`.
                - Carefully analyze the content (title, body, comments) of the original issue and all potential duplicates.
                - Based on your analysis, create a final list containing only the issues you are highly confident are actual duplicates.
                - If your final list is empty, you are done.
                - Print to the logs if you omitted any potential duplicates based on your analysis.
                - If the `duplicates` tool returned 15+ results, use the top 15 matches (based on descending similarity score value) to perform this step.

            3.  **Format Final Duplicates List:**
                Format the final list of duplicates into a markdown string.
                The format should be:
                "Found possible duplicate issues:\n\n- #${issue_number}: ${issue_title}"
                Add an HTML comment to the end for identification: `<!-- gemini-cli-deduplication -->`

            4.  **Check for Existing Comment:**
                - Run `gh issue view "${ISSUE_NUMBER}" --json comments` to get all
                  comments on the issue.
                - Look for a comment made by a bot (the author's login often ends in `[bot]`) that contains `<!-- gemini-cli-deduplication -->`.
                - If you find such a comment, store its `id` and `body`.

            5.  **Decide Action:**
                - **If an existing comment is found:**
                    - Compare the new list of duplicate issues with the list from the existing comment's body.
                    - If they are the same, do nothing.
                    - If they are different, edit the existing comment. Use
                      `gh issue comment "${ISSUE_NUMBER}" --edit-comment <comment-id> --body "..."`.
                      The new body should be the new list of duplicates, but with the header "Found possible duplicate issues (updated):".
                - **If no existing comment is found:**
                    - Create a new comment with the list of duplicates.
                    - Use `gh issue comment "${ISSUE_NUMBER}" --body "..."`.

            6.  **Add Duplicate Label:**
                - If you created or updated a comment in the previous step, add the `duplicate` label to the current issue.
                - Use `gh issue edit "${ISSUE_NUMBER}" --add-label "duplicate"`.

            ## Guidelines

            - Only use the `duplicates` and `run_shell_command` tools.
            - The `run_shell_command` tool can be used with `gh issue view`, `gh issue comment`, and `gh issue edit`.
            - Do not download or read media files like images, videos, or links. The `--json` flag for `gh issue view` will prevent this.
            - Do not modify the issue content or status.
            - Only comment on and label the current issue.
            - Reference all shell variables as "${VAR}" (with quotes and braces)
